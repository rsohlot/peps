
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>PEP 690 – Lazy Imports | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="canonical" href="https://peps.python.org/pep-0690.html" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light" />
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark" />
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://www.python.org/dev/peps/peps.rss">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 690</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 690 – Lazy Imports</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Germán Méndez Bravo &lt;german.mb&#32;&#97;t&#32;gmail.com&gt;, Carl Meyer &lt;carl&#32;&#97;t&#32;oddbird.net&gt;</dd>
<dt class="field-even">Sponsor<span class="colon">:</span></dt>
<dd class="field-even">Barry Warsaw &lt;barry&#32;&#97;t&#32;python.org&gt;</dd>
<dt class="field-odd">Discussions-To<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="https://discuss.python.org/t/pep-690-lazy-imports/15474">Discourse thread</a></dd>
<dt class="field-even">Status<span class="colon">:</span></dt>
<dd class="field-even">Draft</dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd">Standards Track</dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">29-Apr-2022</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.12</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/pep-690-lazy-imports/15474" title="Discourse thread">03-May-2022</a>,
<a class="reference external" href="https://mail.python.org/archives/list/python-dev&#64;python.org/thread/IHOSWMIBKCXVB46FI7NGOC2F34RUYZ5Z/" title="Python-Dev thread">03-May-2022</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#debuggability">Debuggability</a></li>
<li><a class="reference internal" href="#per-module-opt-out">Per-module opt out</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#import-side-effects">Import Side Effects</a></li>
<li><a class="reference internal" href="#dynamic-paths">Dynamic Paths</a></li>
<li><a class="reference internal" href="#deferred-exceptions">Deferred Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#performance-impact">Performance Impact</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#per-module-opt-in">Per-module opt-in</a></li>
<li><a class="reference internal" href="#explicit-syntax-for-lazy-imports">Explicit syntax for lazy imports</a></li>
<li><a class="reference internal" href="#half-lazy-imports">Half-lazy imports</a></li>
<li><a class="reference internal" href="#lazy-dynamic-imports">Lazy dynamic imports</a></li>
<li><a class="reference internal" href="#deep-eager-imports-override">Deep eager-imports override</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>This PEP proposes a feature to transparently defer the execution of imported
modules until the moment when an imported object is used.  Since Python
programs commonly import many more modules than a single invocation of the
program is likely to use in practice, lazy imports can greatly reduce the
overall number of modules loaded, improving startup time and memory usage. Lazy
imports also mostly eliminate the risk of import cycles.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Common Python code style <a class="pep reference internal" href="../pep-0008#imports" title="PEP 8 – Style Guide for Python Code § Imports">prefers</a> imports at module
level, so they don’t have to be repeated within each scope the imported object
is used in, and to avoid the inefficiency of repeated execution of the import
system at runtime. This means that importing the main module of a program
typically results in an immediate cascade of imports of most or all of the
modules that may ever be needed by the program.</p>
<p>Consider the example of a Python command line program with a number of
subcommands. Each subcommand may perform different tasks, requiring the import
of different dependencies. But a given invocation of the program will only
execute a single subcommand, or possibly none (i.e. if just <code class="docutils literal notranslate"><span class="pre">--help</span></code> usage
info is requested). Top-level eager imports in such a program will result in
the import of many modules that will never be used at all; the time spent
(possibly compiling and) executing these modules is pure waste.</p>
<p>In an effort to improve startup time, some large Python CLIs tools make imports
lazy by manually placing imports inline into functions to delay imports of
expensive subsystems. This manual approach is labor-intensive and fragile; one
misplaced import or refactor can easily undo painstaking optimization work.</p>
<p>Existing import-hook-based solutions such as <a class="reference external" href="https://github.com/bwesterb/py-demandimport/">demandimport</a> or <a class="reference external" href="https://docs.python.org/3/library/importlib.html#importlib.util.LazyLoader">importlib.util.LazyLoader</a>
are limited in that only certain styles of import can be made truly lazy
(imports such as <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">a,</span> <span class="pre">b</span></code> will still eagerly import the module
<code class="docutils literal notranslate"><span class="pre">foo</span></code>) and they impose additional runtime overhead on every module attribute
access.</p>
<p>This PEP proposes a more comprehensive solution for lazy imports that does not
impose detectable overhead in real-world use. The implementation in this PEP
has already <a class="reference external" href="https://github.com/facebookincubator/cinder/blob/cinder/3.8/CinderDoc/lazy_imports.rst">demonstrated</a>
startup time improvements up to 70% and memory-use reductions up to
40% on real-world Python CLIs.</p>
<p>Lazy imports also eliminate most import cycles. With eager imports, “false
cycles” can easily occur which are fixed by simply moving an import to the
bottom of a module or inline into a function, or switching from <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span>
<span class="pre">import</span> <span class="pre">bar</span></code> to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo</span></code>. With lazy imports, these “cycles” just work.
The only cycles which will remain are those where two modules actually each use
a name from the other at module level; these “true” cycles are only fixable by
refactoring the classes or functions involved.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<p>The aim of this feature is to make imports transparently lazy. “Lazy” means
that the import of a module (execution of the module body and addition of the
module object to <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>) should not occur until the module (or a name
imported from it) is actually referenced during execution. “Transparent” means
that besides the delayed import (and necessarily observable effects of that,
such as delayed import side effects and changes to <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>), there is
no other observable change in behavior: the imported object is present in the
module namespace as normal and is transparently loaded whenever first used: its
status as a “lazy imported object” is not directly observable from Python or
from C extension code.</p>
<p>The requirement that the imported object be present in the module namespace as
usual, even before the import has actually occurred, means that we need some
kind of “lazy object” placeholder to represent the not-yet-imported object.
The transparency requirement dictates that this placeholder must never be
visible to Python code; any reference to it must trigger the import and replace
it with the real imported object.</p>
<p>Given the possibility that Python (or C extension) code may pull objects
directly out of a module <code class="docutils literal notranslate"><span class="pre">__dict__</span></code>, the only way to reliably prevent
accidental leakage of lazy objects is to have the dictionary itself be
responsible to ensure resolution of lazy objects on lookup.</p>
<p>To avoid a performance penalty on the vast majority of dictionaries which never
contain any lazy objects, we install a specialized lookup function
(<code class="docutils literal notranslate"><span class="pre">lookdict_unicode_lazy</span></code>) for module namespace dictionaries when they first
gain a lazy-object value. When this lookup function finds that the key
references a lazy object, it resolves the lazy object immediately before
returning it.</p>
<p>Some operations on dictionaries (e.g. iterating all values) don’t go through
the lookup function; in these cases we have to add a check if the lookup
function is <code class="docutils literal notranslate"><span class="pre">lookdict_unicode_lazy</span></code> and if so, resolve all lazy values first.</p>
<p>This implementation comprehensively prevents leakage of lazy objects, ensuring
they are always resolved to the real imported object before anyone can get hold
of them for any use, while avoiding any significant performance impact on
dictionaries in general.</p>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>Lazy imports are opt-in, and globally enabled via a new <code class="docutils literal notranslate"><span class="pre">-L</span></code> flag to the
Python interpreter, or a <code class="docutils literal notranslate"><span class="pre">PYTHONLAZYIMPORTS</span></code> environment variable.</p>
<p>When enabled, the loading and execution of all (and only) top level imports is
deferred until the imported name is used. This could happen immediately (e.g.
on the very next line after the import statement) or much later (e.g. while
using the name inside a function being called by some other code at some later
time.)</p>
<p>For these top level imports, there are two exceptions which will make them
eager (not lazy): imports inside <code class="docutils literal notranslate"><span class="pre">try</span></code>/<code class="docutils literal notranslate"><span class="pre">except</span></code>/<code class="docutils literal notranslate"><span class="pre">finally</span></code>  or <code class="docutils literal notranslate"><span class="pre">with</span></code>
blocks, and star imports (<code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo</span> <span class="pre">import</span> <span class="pre">*</span></code>.) Imports inside
exception-handling blocks (this includes <code class="docutils literal notranslate"><span class="pre">with</span></code> blocks, since those can also
“catch” and handle exceptions) remain eager so that any exceptions arising from
the import can be handled. Star imports must remain eager since performing the
import is the only way to know which names should be added to the namespace.</p>
<p>Imports inside class definitions or inside functions/methods are not “top
level” and are never lazy.</p>
<p>Dynamic imports using <code class="docutils literal notranslate"><span class="pre">__import__()</span></code> or <code class="docutils literal notranslate"><span class="pre">importlib.import_module()</span></code> are
also never lazy.</p>
<section id="example">
<h3><a class="toc-backref" href="#example" role="doc-backlink">Example</a></h3>
<p>Say we have a module <code class="docutils literal notranslate"><span class="pre">spam.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># simulate some work</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spam loaded&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>And a module <code class="docutils literal notranslate"><span class="pre">eggs.py</span></code> which imports it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spam</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;imports done&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If we run <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-L</span> <span class="pre">eggs.py</span></code>, the <code class="docutils literal notranslate"><span class="pre">spam</span></code> module will never be imported
(because it is never referenced after the import), <code class="docutils literal notranslate"><span class="pre">&quot;spam</span> <span class="pre">loaded&quot;</span></code> will never
be printed, and there will be no 10 second delay.</p>
<p>But if <code class="docutils literal notranslate"><span class="pre">eggs.py</span></code> simply references the name <code class="docutils literal notranslate"><span class="pre">spam</span></code> after importing it, that
will be enough to trigger the import of <code class="docutils literal notranslate"><span class="pre">spam.py</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">spam</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;imports done&quot;</span><span class="p">)</span>
<span class="n">spam</span>
</pre></div>
</div>
<p>Now if we run <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-L</span> <span class="pre">eggs.py</span></code>, we will see the output <code class="docutils literal notranslate"><span class="pre">&quot;imports</span> <span class="pre">done&quot;</span></code>
printed first, then a 10 second delay, and then <code class="docutils literal notranslate"><span class="pre">&quot;spam</span> <span class="pre">loaded&quot;</span></code> printed after
that.</p>
<p>Of course, in real use cases (especially with lazy imports), it’s not
recommended to rely on import side effects like this to trigger real work. This
example is just to clarify the behavior of lazy imports.</p>
</section>
<section id="debuggability">
<h3><a class="toc-backref" href="#debuggability" role="doc-backlink">Debuggability</a></h3>
<p>The implementation will ensure that exceptions resulting from a deferred import
have metadata attached pointing the user to the original import statement, to
ease debuggability of errors from lazy imports.</p>
<p>Additionally, debug logging from <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-v</span></code> will include logging when an
import statement has been encountered but execution of the import will be
deferred.</p>
<p>Python’s <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">importtime</span></code> feature for profiling import costs adapts naturally
to lazy imports; the profiled time is the time spent actually importing.</p>
</section>
<section id="per-module-opt-out">
<h3><a class="toc-backref" href="#per-module-opt-out" role="doc-backlink">Per-module opt out</a></h3>
<p>Due to the backwards compatibility issues mentioned below, it may be necessary
to force some imports to be eager.</p>
<p>In first-party code, since imports inside a <code class="docutils literal notranslate"><span class="pre">try</span></code> or <code class="docutils literal notranslate"><span class="pre">with</span></code> block are never
lazy, this can be easily accomplished:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>  <span class="c1"># force these imports to be eager</span>
    <span class="kn">import</span> <span class="nn">foo</span>
    <span class="kn">import</span> <span class="nn">bar</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>This PEP proposes to add a new <code class="docutils literal notranslate"><span class="pre">importlib.eager_imports()</span></code> context manager,
so the above technique can be less verbose and doesn’t require comments to
clarify its intent:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">eager_imports</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">foo</span>
    <span class="kn">import</span> <span class="nn">bar</span>
</pre></div>
</div>
<p>Since imports within context managers are always eager, the <code class="docutils literal notranslate"><span class="pre">eager_imports()</span></code>
context manager can just be an alias to a null context manager. The context
manager does not force all imports to be recursively eager: <code class="docutils literal notranslate"><span class="pre">foo</span></code> and <code class="docutils literal notranslate"><span class="pre">bar</span></code>
will be imported eagerly, but imports within those modules will still follow
the usual laziness rules.</p>
<p>The more difficult case can occur if an import in third-party code that can’t
easily be modified must be forced to be eager. For this purpose, we propose to
add an API to <code class="docutils literal notranslate"><span class="pre">importlib</span></code> that can be called early in the process to specify
a list of module names within which all imports will be eager:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">set_eager_imports</span>

<span class="n">set_eager_imports</span><span class="p">([</span><span class="s2">&quot;one.mod&quot;</span><span class="p">,</span> <span class="s2">&quot;another&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>The effect of this is also shallow: all imports within <code class="docutils literal notranslate"><span class="pre">one.mod</span></code> will be
eager, but not imports in all modules imported by <code class="docutils literal notranslate"><span class="pre">one.mod</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">set_eager_imports()</span></code> can also take a callback which receives a module name and returns
whether imports within this module should be eager:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">set_eager_imports</span>

<span class="k">def</span> <span class="nf">eager_imports</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;foo\.[^.]+\.logger&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="n">set_eager_imports</span><span class="p">(</span><span class="n">eager_imports</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>This proposal preserves full backwards compatibility when the feature is
disabled, which is the default.</p>
<p>Even when enabled, most code will continue to work normally without any
observable change (other than improved startup time and memory usage.)
Namespace packages are not affected: they work just as they do currently,
except lazily.</p>
<p>In some existing code, lazy imports could produce currently unexpected results
and behaviors. The problems that we may see when enabling lazy imports in an
existing codebase are related to:</p>
<section id="import-side-effects">
<h3><a class="toc-backref" href="#import-side-effects" role="doc-backlink">Import Side Effects</a></h3>
<p>Import side effects that would otherwise be produced by the execution of
imported modules during the execution of import statements will be deferred at
least until the imported objects are used.</p>
<p>These import side effects may include:</p>
<ul class="simple">
<li>code executing any side-effecting logic during import;</li>
<li>relying on imported submodules being set as attributes in the parent module.</li>
</ul>
<p>A relevant and typical affected case is the <a class="reference external" href="https://click.palletsprojects.com/">click</a> library for building Python command-line
interfaces. If e.g. <code class="docutils literal notranslate"><span class="pre">cli</span> <span class="pre">=</span> <span class="pre">click.group()</span></code> is defined in <code class="docutils literal notranslate"><span class="pre">main.py</span></code>, and
<code class="docutils literal notranslate"><span class="pre">sub.py</span></code> imports <code class="docutils literal notranslate"><span class="pre">cli</span></code> from <code class="docutils literal notranslate"><span class="pre">main</span></code> and adds subcommands to it via
decorator (<code class="docutils literal notranslate"><span class="pre">&#64;cli.command(...)</span></code>), but the actual <code class="docutils literal notranslate"><span class="pre">cli()</span></code> call is in
<code class="docutils literal notranslate"><span class="pre">main.py</span></code>, then lazy imports may prevent the subcommands from being
registered, since in this case Click is depending on side effects of the import
of <code class="docutils literal notranslate"><span class="pre">sub.py</span></code>. In this case the fix is to ensure the import of <code class="docutils literal notranslate"><span class="pre">sub.py</span></code> is
eager, e.g. by using the <code class="docutils literal notranslate"><span class="pre">importlib.eager_imports()</span></code> context manager.</p>
</section>
<section id="dynamic-paths">
<h3><a class="toc-backref" href="#dynamic-paths" role="doc-backlink">Dynamic Paths</a></h3>
<p>There could be issues related to dynamic Python import paths; particularly,
adding (and then removing after the import) paths from <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;/path/to/foo/module&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">foo</span>
<span class="k">del</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">foo</span><span class="o">.</span><span class="n">Bar</span><span class="p">()</span>
</pre></div>
</div>
<p>In this case, with lazy imports enabled, the import of <code class="docutils literal notranslate"><span class="pre">foo</span></code> will not
actually occur while the addition to <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> is present.</p>
</section>
<section id="deferred-exceptions">
<h3><a class="toc-backref" href="#deferred-exceptions" role="doc-backlink">Deferred Exceptions</a></h3>
<p>All exceptions arising from import (including <code class="docutils literal notranslate"><span class="pre">ModuleNotFoundError</span></code>) are
deferred from import time to first-use time, which could complicate debugging.
Accessing an object in the middle of any code could trigger a deferred import
and produce <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> or any other exception resulting from the
resolution of the deferred object, while loading and executing the related
imported module. The implementation will provide debugging assistance in
lazy-import-triggered tracebacks to mitigate this issue.</p>
</section>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>Deferred execution of code could produce security concerns if process owner,
path, <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>, or other sensitive environment or contextual states change
between the time the <code class="docutils literal notranslate"><span class="pre">import</span></code> statement is executed and the time where the
imported object is used.</p>
</section>
<section id="performance-impact">
<h2><a class="toc-backref" href="#performance-impact" role="doc-backlink">Performance Impact</a></h2>
<p>The reference implementation has shown that the feature has negligible
performance impact on existing real-world codebases (Instagram Server and other
several CLI programs at Meta), while providing substantial improvements to
startup time and memory usage.</p>
<p>The reference implementation shows small performance regressions in a few
pyperformance benchmarks, but improvements in others. (TODO update with
detailed data from 3.11 port of implementation.)</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>Since the feature is opt-in, beginners should not encounter it by default.
Documentation of the <code class="docutils literal notranslate"><span class="pre">-L</span></code> flag and <code class="docutils literal notranslate"><span class="pre">PYTHONLAZYIMPORTS</span></code> environment variable
can clarify the behavior of lazy imports.</p>
<p>Some best practices to deal with some of the issues that could arise and to
better take advantage of lazy imports are:</p>
<ul class="simple">
<li>Avoid relying on import side effects. Perhaps the most common reliance on
import side effects is the registry pattern, where population of some
external registry happens implicitly during the importing of modules, often
via decorators. Instead, the registry should be built via an explicit call
that perhaps does a discovery process to find decorated functions or classes.</li>
<li>Always import needed submodules explicitly, don’t rely on some other import
to ensure a module has its submodules as attributes. That is, do <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">foo.bar;</span> <span class="pre">foo.bar.Baz</span></code>, not <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo;</span> <span class="pre">foo.bar.Baz</span></code>. The latter only
works (unreliably) because the attribute <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> is added as a side
effect of <code class="docutils literal notranslate"><span class="pre">foo.bar</span></code> being imported somewhere else. With lazy imports this
may not always happen on time.</li>
<li>Avoid using star imports, as those are always eager.</li>
<li>When possible, do not import whole submodules. Import specific names instead;
i.e.: do <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">foo.bar</span> <span class="pre">import</span> <span class="pre">Baz</span></code>, not <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">foo.bar</span></code> and then
<code class="docutils literal notranslate"><span class="pre">foo.bar.Baz</span></code>. If you import submodules (such as <code class="docutils literal notranslate"><span class="pre">foo.qux</span></code> and
<code class="docutils literal notranslate"><span class="pre">foo.fred</span></code>), with lazy imports enabled, when you access the parent module’s
name (<code class="docutils literal notranslate"><span class="pre">foo</span></code> in this case), that will trigger loading all of the sibling
submodules of the parent module (<code class="docutils literal notranslate"><span class="pre">foo.bar</span></code>, <code class="docutils literal notranslate"><span class="pre">foo.qux</span></code> and <code class="docutils literal notranslate"><span class="pre">foo.fred</span></code>),
not only the one being accessed, because the parent module <code class="docutils literal notranslate"><span class="pre">foo</span></code> is the
actual deferred object name.</li>
</ul>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>The current reference implementation is available as part of
<a class="reference external" href="https://github.com/facebookincubator/cinder">Cinder</a>.
Reference implementation is in use within Meta Platforms and has proven to
achieve improvements in startup time (and total runtime for some applications)
in the range of 40%-70%, as well as significant reduction in memory footprint
(up to 40%), thanks to not needing to execute imports that end up being unused
in the common flow.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="per-module-opt-in">
<h3><a class="toc-backref" href="#per-module-opt-in" role="doc-backlink">Per-module opt-in</a></h3>
<p>A per-module opt-in using e.g. <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">lazy_imports</span></code> has a
couple of disadvantages:</p>
<ul class="simple">
<li>It is less practical to achieve robust and significant startup-time or
memory-use wins by piecemeal application of lazy imports. Generally it would
require blanket application of the <code class="docutils literal notranslate"><span class="pre">__future__</span></code> import to most of the
codebase, as well as to third-party dependencies (which may be hard or
impossible.)</li>
<li><code class="docutils literal notranslate"><span class="pre">__future__</span></code> imports are not feature flags, they are for transition to
behaviors which will become default in the future. It is not clear if lazy
imports will ever make sense as the default behavior, so we should not
promise this with a <code class="docutils literal notranslate"><span class="pre">__future__</span></code> import. Thus, a per-module opt-in would
require a new <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__optional_features__</span> <span class="pre">import</span> <span class="pre">lazy_imports</span></code> or similar
mechanism.</li>
</ul>
<p>Experience with the reference implementation suggests that the most practical
adoption path for lazy imports is for a specific deployed application to opt-in
globally, observe whether anything breaks, and opt-out specific modules as
needed to account for e.g. reliance on import side effects.</p>
</section>
<section id="explicit-syntax-for-lazy-imports">
<h3><a class="toc-backref" href="#explicit-syntax-for-lazy-imports" role="doc-backlink">Explicit syntax for lazy imports</a></h3>
<p>If the primary objective of lazy imports were solely to work around import
cycles and forward references, an explicitly-marked syntax for particular
targeted imports to be lazy would make a lot of sense. But in practice it would
be very hard to get robust startup time or memory use benefits from this
approach, since it would require converting most imports within your code base
(and in third-party dependencies) to use the lazy import syntax.</p>
<p>It would be possible to aim for a “shallow” laziness where only the top-level
imports of subsystems from the main module are made explicitly lazy, but then
imports within the subsystems are all eager. This is extremely fragile, though
– it only takes one mis-placed import to undo the carefully constructed
shallow laziness. Globally enabling lazy imports, on the other hand, provides
in-depth robust laziness where you always pay only for the imports you use.</p>
</section>
<section id="half-lazy-imports">
<h3><a class="toc-backref" href="#half-lazy-imports" role="doc-backlink">Half-lazy imports</a></h3>
<p>It would be possible to eagerly run the import loader to the point of finding
the module source, but then defer the actual execution of the module and
creation of the module object. The advantage of this would be that certain
classes of import errors (e.g. a simple typo in the module name) would be
caught eagerly instead of being deferred to the use of an imported name.</p>
<p>The disadvantage would be that the startup time benefits of lazy imports would
be significantly reduced, since unused imports would still require a filesystem
<code class="docutils literal notranslate"><span class="pre">stat()</span></code> call, at least. It would also introduce a possibly non-obvious split
between <em>which</em> import errors are raised eagerly and which are delayed, when
lazy imports are enabled.</p>
<p>This idea is rejected for now on the basis that in practice, confusion about
import typos has not been an observed problem with the reference
implementation. Generally delayed imports are not delayed forever, and errors
show up soon enough to be caught and fixed (unless the import is truly unused.)</p>
</section>
<section id="lazy-dynamic-imports">
<h3><a class="toc-backref" href="#lazy-dynamic-imports" role="doc-backlink">Lazy dynamic imports</a></h3>
<p>It would be possible to add a <code class="docutils literal notranslate"><span class="pre">lazy=True</span></code> or similar option to
<code class="docutils literal notranslate"><span class="pre">__import__()</span></code> and/or <code class="docutils literal notranslate"><span class="pre">importlib.import_module()</span></code>, to enable them to
perform lazy imports.  That idea is rejected in this PEP for lack of a clear
use case. Dynamic imports are already far outside the <a class="pep reference internal" href="../pep-0008" title="PEP 8 – Style Guide for Python Code">PEP 8</a> code style
recommendations for imports, and can easily be made precisely as lazy as
desired by placing them at the desired point in the code flow. These aren’t
commonly used at module top level, which is where lazy imports applies.</p>
</section>
<section id="deep-eager-imports-override">
<h3><a class="toc-backref" href="#deep-eager-imports-override" role="doc-backlink">Deep eager-imports override</a></h3>
<p>The proposed <code class="docutils literal notranslate"><span class="pre">importlib.eager_imports()</span></code> context manager and
<code class="docutils literal notranslate"><span class="pre">importlib.set_eager_imports()</span></code> override both have shallow effects: they only
force eagerness for the location where they are applied, not transitively. It
would be possible (although not simple) to provide a deep/transitive version of
one or both. That idea is rejected in this PEP because experience with the
reference implementation has not shown it to be necessary, and because it
prevents local reasoning about laziness of imports.</p>
<p>A deep override can lead to confusing behavior because the
transitively-imported modules may be imported from multiple locations, some of
which use the “deep eager override” and some of which don’t. Thus those modules
may still be imported lazily initially, if they are first imported from a
location that doesn’t have the override.</p>
<p>With deep overrides it is not possible to locally reason about whether a given
import will be lazy or eager. With the behavior specified in this PEP, such
local reasoning is possible.</p>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0690.rst">https://github.com/python/peps/blob/main/pep-0690.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0690.rst">2022-05-21 20:04:08 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a></li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#debuggability">Debuggability</a></li>
<li><a class="reference internal" href="#per-module-opt-out">Per-module opt out</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a><ul>
<li><a class="reference internal" href="#import-side-effects">Import Side Effects</a></li>
<li><a class="reference internal" href="#dynamic-paths">Dynamic Paths</a></li>
<li><a class="reference internal" href="#deferred-exceptions">Deferred Exceptions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#performance-impact">Performance Impact</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#per-module-opt-in">Per-module opt-in</a></li>
<li><a class="reference internal" href="#explicit-syntax-for-lazy-imports">Explicit syntax for lazy imports</a></li>
<li><a class="reference internal" href="#half-lazy-imports">Half-lazy imports</a></li>
<li><a class="reference internal" href="#lazy-dynamic-imports">Lazy dynamic imports</a></li>
<li><a class="reference internal" href="#deep-eager-imports-override">Deep eager-imports override</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br />
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0690.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>